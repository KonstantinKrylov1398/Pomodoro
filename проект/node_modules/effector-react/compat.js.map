{"version":3,"file":"compat.js","sources":["effector-react/createWatch.ts","effector-react/withDisplayName.ts","effector-react/apiBase.ts","effector-react/nossr.ts","effector-react/createComponent.ts","effector-react/../effector/config.ts","effector-react/../effector/is.ts","effector-react/../effector/throw.ts","effector-react/createGate.ts","effector-react/throw.ts","effector-react/useIsomorphicLayoutEffect.ts","effector-react/deprecate.ts","effector-react/connect.ts","effector-react/../effector/collection.ts","effector-react/createContextComponent.ts","effector-react/createReactState.ts","effector-react/createStoreConsumer.ts"],"sourcesContent":["import {Store, clearNode, step, createNode, Scope, Node, Cmd} from 'effector'\n\nexport function createWatch<T>(\n  store: Store<T>,\n  fn: (value: T) => any,\n  scope?: Scope,\n  batchStep?: Cmd,\n) {\n  const seq: Cmd[] = [step.run({fn: value => fn(value)})]\n  if (batchStep) seq.unshift(batchStep)\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (store as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return () => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    }\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [store],\n      family: {owners: store},\n    })\n    return () => {\n      clearNode(node)\n    }\n  }\n}\n","export function withDisplayName(name: string, Component: any) {\n  Component.displayName = name\n  return Component\n}\n","import {Store, is, step, scopeBind, Scope, Unit, Event} from 'effector'\nimport React from 'react'\nimport {useSyncExternalStore} from 'use-sync-external-store/shim'\nimport {useSyncExternalStoreWithSelector} from 'use-sync-external-store/shim/with-selector'\nimport {throwError} from './throw'\nimport {createWatch} from './createWatch'\nimport {withDisplayName} from './withDisplayName'\n\nconst stateReader = <T>(store: Store<T>, scope?: Scope) =>\n  scope ? scope.getState(store) : store.getState()\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\nconst keysEqual = (a?: readonly any[], b?: readonly any[]) => {\n  if (!a || !b || a.length !== b.length) return false\n\n  let isEqual = true\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      isEqual = false\n      break\n    }\n  }\n\n  return isEqual\n}\n\nexport function useStoreBase<State>(store: Store<State>, scope?: Scope) {\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n  const currentValue = useSyncExternalStore(subscribe, read, read)\n\n  return currentValue\n}\n\nexport function useUnitBase<Shape extends {[key: string]: Unit<any>}>(\n  shape: Shape,\n  scope?: Scope,\n) {\n  const isSingleUnit = is.unit(shape)\n  const normShape: {[key: string]: Unit<any>} = isSingleUnit\n    ? {unit: shape}\n    : shape\n  const isList = Array.isArray(normShape)\n  const flagsRef = React.useRef({\n    stale: true,\n    wasSubscribed: false,\n    justSubscribed: false,\n  })\n  const [eventsShape, storeKeys, storeValues] = React.useMemo(() => {\n    flagsRef.current.stale = true\n    const shape = Array.isArray(normShape) ? [] : ({} as any)\n    const storeKeys: string[] = []\n    const storeValues: Array<Store<any>> = []\n    for (const key in normShape) {\n      const unit = normShape[key]\n      if (!is.unit(unit)) throwError('expect useUnit argument to be a unit')\n      if (is.event(unit) || is.effect(unit)) {\n        shape[key] = scope ? scopeBind(unit as Event<any>, {scope}) : unit\n      } else {\n        shape[key] = null\n        storeKeys.push(key)\n        storeValues.push(unit as Store<any>)\n      }\n    }\n    return [shape, storeKeys, storeValues]\n  }, [flagsRef, scope, ...Object.keys(normShape), ...Object.values(normShape)])\n  const stateRef = React.useRef({value: eventsShape, storeKeys})\n  const subscribe = React.useCallback(\n    (cb: () => void) => {\n      const flags = flagsRef.current\n      if (flags.wasSubscribed) flags.justSubscribed = true\n      const cbCaller = () => {\n        if (!flags.stale) {\n          flags.stale = true\n          cb()\n        }\n      }\n      const batchStep = step.compute({priority: 'sampler', batch: true})\n      const subs = storeValues.map(store =>\n        createWatch(store, cbCaller, scope, batchStep),\n      )\n      flags.wasSubscribed = true\n      return () => {\n        subs.forEach(fn => fn())\n      }\n    },\n    [storeValues, scope, stateRef, flagsRef],\n  )\n  const read = React.useCallback(() => {\n    const state = stateRef.current\n    const flags = flagsRef.current\n    let resultValue\n    let changed = false\n    const oldVal = state.value\n    const oldKeys = state.storeKeys\n    if (\n      (storeKeys.length > 0 || oldKeys.length > 0) &&\n      (flags.stale || flags.justSubscribed)\n    ) {\n      changed = !flags.justSubscribed\n      resultValue = isList ? [...eventsShape] : {...eventsShape}\n      if (oldKeys.length !== storeKeys.length) {\n        changed = true\n      }\n      for (let i = 0; i < storeKeys.length; i++) {\n        const updatedValue = stateReader(storeValues[i], scope)\n        const key = storeKeys[i]\n        if (!changed) {\n          if (!oldKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldVal[key] !== updatedValue\n          }\n        }\n        resultValue[key] = updatedValue\n      }\n    }\n    if (changed) {\n      state.value = resultValue\n    }\n    state.storeKeys = storeKeys\n    flags.stale = false\n    flags.justSubscribed = false\n    return isSingleUnit ? state.value.unit : state.value\n  }, [subscribe, flagsRef])\n  return useSyncExternalStore(subscribe, read, read)\n}\n\nexport function useStoreMapBase<State, Result, Keys extends ReadonlyArray<any>>(\n  [configOrStore, separateFn]: [\n    configOrStore:\n      | {\n          store: Store<State>\n          keys: Keys\n          fn(state: State, keys: Keys): Result\n          updateFilter?: (update: Result, current: Result) => boolean\n          defaultValue?: Result\n        }\n      | Store<State>,\n    separateFn?: (state: State, keys: Keys) => Result,\n  ],\n  scope?: Scope,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean =\n    basicUpdateFilter\n  let defaultValue: Result | undefined\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = [] as unknown as Keys\n  } else {\n    ;({\n      fn,\n      store,\n      keys,\n      defaultValue,\n      updateFilter = basicUpdateFilter,\n    } = configOrStore as any)\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n\n  const stateRef = React.useRef<State>()\n  const valueRef = React.useRef<Result>()\n  const keysRef = React.useRef(keys)\n\n  const value = useSyncExternalStoreWithSelector(\n    subscribe,\n    read,\n    read,\n    state => {\n      if (stateRef.current !== state || !keysEqual(keysRef.current, keys)) {\n        let result = fn(state, keys)\n        if (result === undefined && defaultValue !== undefined) {\n          result = defaultValue\n        }\n        stateRef.current = state\n        keysRef.current = keys\n\n        /**\n         * skip update, if undefined\n         * just like original store or previous implementation\n         */\n        if (result !== undefined) {\n          valueRef.current = result\n        }\n      }\n\n      return valueRef.current as Result\n    },\n    (current, update) => !updateFilter(update, current),\n  )\n\n  return value\n}\nexport function useListBase<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  scope?: Scope,\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: ((item: T) => string) | void\n  let placeholder: React.ReactNode | void\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    ;({fn, getKey, placeholder} = renderItem)\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMapBase(\n          [\n            {\n              store: list,\n              keys: [index, ...keys],\n              fn: (list, keys) => list[keys[0]],\n            },\n          ],\n          scope,\n        )\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, scope, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    const listItems = useStoreBase(list, scope)\n    if (listItems.length === 0 && placeholder) return placeholder\n    return listItems.map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMapBase(\n      [\n        {\n          store: list,\n          keys: [list],\n          fn: list => list.length,\n        },\n      ],\n      scope,\n    )\n    if (length === 0 && placeholder) return placeholder\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n","import {Event, Store} from 'effector'\nimport {\n  useStoreBase,\n  useStoreMapBase,\n  useListBase,\n  useUnitBase,\n} from './apiBase'\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent<T>(event: Event<T>): (payload: T) => T {\n  return event\n}\n\nexport function useStore<State>(store: Store<State>): State {\n  return useStoreBase(store)\n}\n\nexport function useUnit(shape) {\n  return useUnitBase(shape)\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n        defaultValue?: Result\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  return useStoreMapBase([configOrStore, separateFn])\n}\n\nexport function useList<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n): React.ReactNode {\n  return useListBase(list, renderItem)\n}\n","import React from 'react'\nimport {Store, is, combine, createEvent} from 'effector'\nimport {useStore} from './nossr'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {StoreView} from './index.h'\nimport {withDisplayName} from './withDisplayName'\nimport {throwError} from './throw'\n\nexport function createComponent<Props, State>(\n  shape: Store<State> | {[key: string]: Store<any> | any},\n  renderProp: (props: Props, state: State) => React.ReactNode,\n): StoreView<State, Props> {\n  let store: Store<any>\n  if (is.store(shape)) {\n    store = shape\n  } else {\n    if (typeof shape === 'object' && shape !== null) {\n      store = combine(shape)\n    } else throwError('shape should be a store or object with stores')\n  }\n  let storeName = 'Unknown'\n  //@ts-ignore\n  if (store && store.shortName) {\n    storeName = store.shortName\n  }\n  const mounted = createEvent<any>()\n  const unmounted = createEvent<any>()\n\n  function RenderComponent(props: Props) {\n    const propsRef = React.useRef(props)\n    const state = useStore(store)\n    useIsomorphicLayoutEffect(() => {\n      mounted({props: propsRef.current, state: store.getState()})\n      return () => {\n        unmounted({props: propsRef.current, state: store.getState()})\n      }\n    }, [])\n    const result = renderProp(props, state)\n    propsRef.current = props\n    return result\n  }\n  RenderComponent.mounted = mounted\n  RenderComponent.unmounted = unmounted\n  return withDisplayName(`${storeName}.View`, RenderComponent)\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import React from 'react'\nimport {createStore, launch, Store, Domain, createEvent} from 'effector'\nimport {Gate} from './index.h'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {withDisplayName} from './withDisplayName'\nimport {flattenConfig, processArgsToConfig} from '../effector/config'\nimport {isObject} from '../effector/is'\n\nexport function useGate<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n) {\n  const propsRef = React.useRef<{value: any; count: number}>({\n    value: null,\n    count: 0,\n  })\n  useIsomorphicLayoutEffect(() => {\n    GateComponent.open(propsRef.current.value)\n    return () => GateComponent.close(propsRef.current.value) as any\n  }, [GateComponent])\n  if (!shallowCompare(propsRef.current.value, props)) {\n    propsRef.current.value = props\n    propsRef.current.count += 1\n  }\n  useIsomorphicLayoutEffect(() => {\n    GateComponent.set(propsRef.current.value)\n  }, [propsRef.current.count])\n}\n\nfunction shallowCompare(a: any, b: any) {\n  if (a === b) return true\n  if (\n    typeof a === 'object' &&\n    a !== null &&\n    typeof b === 'object' &&\n    b !== null\n  ) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      const key = aKeys[i]\n      if (a[key] !== b[key]) return false\n    }\n    return true\n  }\n  return false\n}\nexport function createGateImplementation<State>({\n  domain,\n  defaultState,\n  hook: useGateHook,\n  mainConfig,\n  maybeConfig,\n}: {\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGate\n  mainConfig?: Record<string, any>\n  maybeConfig?: Record<string, any> & {sid?: string}\n}): Gate<State> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: mainConfig,\n  }) as {sid: string | undefined; name: string | undefined}\n  const name = config.name || 'gate'\n  const fullName = `${domain ? `${domain.compositeName.fullName}/` : ''}${name}`\n  const set = createEvent<State>({\n    name: `${fullName}.set`,\n    sid: config.sid ? `${config.sid}|set` : undefined,\n  })\n  const open = createEvent<State>({\n    name: `${fullName}.open`,\n    sid: config.sid ? `${config.sid}|open` : undefined,\n  })\n  const close = createEvent<State>({\n    name: `${fullName}.close`,\n    sid: config.sid ? `${config.sid}|close` : undefined,\n  })\n  const status = createStore(Boolean(false), {\n    name: `${fullName}.status`,\n    serialize: 'ignore',\n    // doesn't need to have sid, because it is internal store, should not be serialized\n  })\n    .on(open, () => Boolean(true))\n    .on(close, () => Boolean(false))\n  const state = createStore(defaultState as State, {\n    name: `${fullName}.state`,\n    sid: config.sid,\n  })\n    .on(set, (_, state) => state)\n    .on(open, (_, state) => state)\n    .reset(close)\n  if (domain) {\n    const {hooks} = domain as any\n    launch({\n      target: [\n        hooks.store,\n        hooks.store,\n        hooks.event,\n        hooks.event,\n        hooks.event,\n      ] as any,\n      params: [status, state, open, close, set],\n    })\n  }\n  function GateComponent(props: State) {\n    useGateHook(GateComponent as any, props)\n    return null\n  }\n  GateComponent.open = open\n  GateComponent.close = close\n  GateComponent.status = status\n  GateComponent.state = state\n  GateComponent.set = set\n  return withDisplayName(`Gate:${fullName}`, GateComponent)\n}\n\nconst isPluginConfig = (config: Record<string, any> | string) =>\n  isObject(config) && 'sid' in config\n\nconst isGateConfig = (config: Record<string, any> | string) =>\n  isObject(config) &&\n  ('domain' in config || 'defaultState' in config || 'name' in config)\n\nconst isStructuredConfig = (arg: unknown) =>\n  isObject(arg) && (arg.and || arg.or)\n\nexport function processCreateGateConfig<State>(\n  hook: typeof useGate,\n  args: unknown[],\n): {\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGate\n  mainConfig?: Record<string, any>\n  maybeConfig?: Record<string, any> & {sid?: string}\n} {\n  const universalConfig =\n    args && isStructuredConfig(args[0]) ? args : [{and: args}]\n  const [[nameOrConfig, defaultStateOrConfig], metadata] =\n    processArgsToConfig(universalConfig)\n\n  let domain\n  let defaultState = {}\n  let mainConfig = {}\n  let maybeConfig = metadata\n\n  if (typeof nameOrConfig === 'string') {\n    mainConfig = {name: nameOrConfig}\n    if (isPluginConfig(defaultStateOrConfig)) {\n      // maybeConfig = defaultStateOrConfig\n    } else {\n      defaultState = defaultStateOrConfig || {}\n    }\n  } else if (isGateConfig(nameOrConfig)) {\n    mainConfig = nameOrConfig\n    defaultState = nameOrConfig.defaultState || {}\n    domain = nameOrConfig.domain\n  }\n  return {\n    hook,\n    domain,\n    defaultState,\n    mainConfig,\n    maybeConfig,\n  }\n}\n\nexport function createGate<Props>(...args: unknown[]): Gate<Props> {\n  return createGateImplementation<Props>(processCreateGateConfig(useGate, args))\n}\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","export const deprecate = (method: string) =>\n  console.error(`${method} is deprecated`)\n","import React from 'react'\n\nimport type {Store} from 'effector'\nimport {useStore} from './nossr'\nimport {withDisplayName} from './withDisplayName'\n\nexport const connect =\n  <State>(Component: React.ComponentType<any>) =>\n  (store: Store<State>) => {\n    let View: any = Component\n    if (typeof Component !== 'function') {\n      View = store\n      store = Component as any\n    }\n    const wrappedComponentName = View.displayName || View.name || 'Unknown'\n    return withDisplayName(`Connect(${wrappedComponentName})`, (props: any) =>\n      React.createElement(View, {...props, ...useStore(store)}),\n    )\n  }\n","export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","import React from 'react'\nimport type {Store} from 'effector'\nimport {useStore} from './nossr'\nimport {withDisplayName} from './withDisplayName'\nimport {deprecate} from './deprecate'\n\nexport const createContextComponent = <Props, State, Context>(\n  store: Store<State>,\n  context: React.Context<Context>,\n  renderProp: (props: Props, state: State, context: Context) => React.ReactNode,\n): React.ComponentType<Props> => {\n  deprecate('createContextComponent')\n  return withDisplayName(\n    `${store.shortName || 'Unknown'}.ContextComponent`,\n    (props: any) => {\n      const ctx = React.useContext(context)\n      const state = useStore(store)\n      return renderProp(props, state, ctx)\n    },\n  )\n}\n","import type {ComponentType} from 'react'\nimport type {Store} from 'effector'\n\nimport {connect} from './connect'\nimport {deprecate} from './deprecate'\n\nexport const createReactState = (\n  store: Store<any>,\n  View: ComponentType<any>,\n) => {\n  deprecate('createReactState')\n  return connect(View)(store)\n}\n","import {Store} from 'effector'\n\nimport {StoreConsumer} from './index.h'\nimport {createComponent} from './createComponent'\n\nexport function createStoreConsumer<State>(\n  store: Store<State>,\n): StoreConsumer<State> {\n  return createComponent(store, ({children}, state) => children(state))\n}\n"],"names":["createWatch","store","fn","scope","batchStep","seq","step","run","value","unshift","node","createNode","id","graphite","scopeLinks","additionalLinks","links","push","idx","indexOf","splice","clearNode","parent","family","owners","withDisplayName","name","Component","displayName","useStoreBase","is","throwError","subscribe","React","useCallback","cb","read","stateReader","useSyncExternalStore","useStoreMapBase","defaultValue","keys","configOrStore","separateFn","updateFilter","basicUpdateFilter","Array","isArray","stateRef","useRef","valueRef","keysRef","useSyncExternalStoreWithSelector","state","current","a","b","length","isEqual","i","keysEqual","result","undefined","update","useStore","createComponent","shape","renderProp","RenderComponent","props","propsRef","useIsomorphicLayoutEffect","mounted","getState","unmounted","combine","storeName","shortName","createEvent","processArgsToConfig","args","singleArgument","rawConfig","condition","Error","assert","isObject","isFunction","metadata","or","childConfig","and","unwrappedNestedValue","nested","useGate","GateComponent","count","open","close","aKeys","Object","bKeys","key","shallowCompare","set","createGateImplementation","useGateHook","domain","defaultState","hook","config","flattenConfig","maybeConfig","mainConfig","fullName","compositeName","sid","status","createStore","Boolean","serialize","on","_","reset","hooks","launch","target","event","params","processCreateGateConfig","arg","nameOrConfig","defaultStateOrConfig","isGateConfig","message","upd","oldValue","window","useLayoutEffect","useEffect","deprecate","method","console","error","connect","View","createElement","part","obj","field","isVoid","forIn","context","ctx","useContext","children","list","renderItem","getKey","placeholder","Item","useMemo","index","fnRef","keyVal","item","memo","keysSelfMemo","listItems","map","from","useListBase","isSingleUnit","unit","normShape","isList","flagsRef","stale","wasSubscribed","justSubscribed","storeKeys","storeValues","effect","scopeBind","values","eventsShape","flags","cbCaller","compute","priority","batch","subs","forEach","resultValue","changed","oldVal","oldKeys","updatedValue","includes","useUnitBase"],"mappings":"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"}